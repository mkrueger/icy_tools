use super::*;
use super::{tool_registry, tools};
use tools::ToolHandler;

use crate::Settings;
use icy_engine_edit::EditState;
use icy_engine_edit::tools::Tool;
use std::path::PathBuf;
use std::sync::Arc;

use clipboard_rs::{Clipboard, ClipboardContent};
use iced::{Element, Length, Task};
use icy_engine::formats::FileFormat;
use icy_engine::{MouseButton, Screen, TextBuffer, TextPane};
use icy_engine_gui::{ICY_CLIPBOARD_TYPE, TerminalMessage};
use parking_lot::{Mutex, RwLock};

use super::widget::outline_selector::{OutlineSelector, outline_selector_width};

/// Core ANSI editor logic/state (tools, dispatching, canvas, etc.).
///
/// This is the lower-level editor that handles tools, canvas, and buffer operations.
/// `AnsiEditorMainArea` adds the full UI chrome (panels, palette grid, etc.).
/// `CharFontEditor` uses this for editing TDF font glyphs.
pub(crate) struct AnsiEditorCore {
    /// The screen (contains EditState which wraps buffer, caret, undo stack, etc.)
    /// Use screen.lock().as_any_mut().downcast_mut::<EditState>() to access EditState methods
    pub screen: Arc<Mutex<Box<dyn Screen>>>,
    /// Current active tool handler
    current_tool: Box<dyn tools::ToolHandler>,
    /// Top toolbar (tool-specific options)
    pub top_toolbar: TopToolbar,
    /// Color switcher (FG/BG display)
    pub color_switcher: ColorSwitcher,
    /// Canvas view state
    pub canvas: CanvasView,
    /// Shared options
    pub options: Arc<RwLock<Settings>>,
    /// Whether the document is modified
    pub is_modified: bool,

    // === Selection/Drag State ===
    /// Whether mouse is currently dragging
    pub is_dragging: bool,
    /// Tool that currently has mouse capture during a drag (move/up are routed here)
    mouse_capture_tool: Option<MouseCaptureTarget>,
    /// Current selection drag mode
    pub selection_drag: SelectionDrag,
    /// Selection state at start of drag (for resize operations)
    pub start_selection: Option<icy_engine::Rectangle>,

    // === Marker/Guide State ===
    /// Guide position in characters (e.g. 80x25 for a smallscale boundary)
    /// None = guide disabled
    pub guide: Option<(f32, f32)>,
    /// Whether guide is currently visible
    pub show_guide: bool,
    /// Raster/grid spacing in characters (e.g. 8x8)
    /// None = raster disabled
    pub raster: Option<(f32, f32)>,
    /// Whether raster is currently visible
    pub show_raster: bool,
    /// Whether line numbers are shown at the edges
    pub show_line_numbers: bool,
    /// Whether layer borders are shown
    pub show_layer_borders: bool,

    // === Character Selector State ===
    /// If Some, show the character selector popup for the given target
    pub char_selector_target: Option<CharSelectorTarget>,

    // === Paint Stroke State (Pencil/Brush/Erase) ===
    paint_button: MouseButton,

    // === Shape Tool State ===
    /// If true, shape tools clear/erase instead of drawing (Moebius-style shift behavior).
    shape_clear: bool,

    /// Tool handler for Paste/Floating layer
    paste_handler: tools::PasteTool,

    /// Whether the currently-dispatched tool explicitly set a cursor icon via `ToolResult::SetCursorIcon`.
    /// Used to prevent stale cursors (e.g. I-beam) carrying over into other tools.
    tool_set_cursor_icon: bool,

    /// Tool switch requested by a tool result; executed by the wrapper.
    pending_tool_switch: Option<tools::ToolId>,

    /// Remote cursors from collaboration (updated externally)
    remote_cursors: Vec<widget::remote_cursors::RemoteCursor>,

    /// Pending collaboration events to be processed by the parent
    pending_collab_events: Vec<CollabToolEvent>,
}

/// Collaboration events generated by tool results
#[derive(Clone, Debug)]
pub enum CollabToolEvent {
    /// Send paste-as-selection (floating layer blocks)
    PasteAsSelection,
    /// Send operation position update
    Operation(i32, i32),
}

impl AnsiEditorCore {
    /// Wraps the main layout with tool-specific modal overlays (char selector, tag dialog, etc.)
    ///
    /// These modals are owned by Core but need to overlay the full UI, so this method
    /// takes and returns `AnsiEditorMessage` elements while internally using `AnsiEditorCoreMessage`.
    pub(super) fn wrap_with_modals<'a>(&'a self, main_layout: Element<'a, AnsiEditorMessage>) -> Element<'a, AnsiEditorMessage> {
        self.wrap_with_modals_mapped(main_layout, |msg| AnsiEditorMessage::Core(msg))
    }

    /// Generic version of `wrap_with_modals` that works with any message type.
    /// The `map_msg` closure converts `AnsiEditorCoreMessage` to the target message type.
    pub fn wrap_with_modals_mapped<'a, M: Clone + 'a>(
        &'a self,
        main_layout: Element<'a, M>,
        map_msg: impl Fn(AnsiEditorCoreMessage) -> M + Copy + 'a,
    ) -> Element<'a, M> {
        // Compute context for modal rendering (fkeys, font, palette, caret colors).
        let (fkeys, current_font, palette, caret_fg, caret_bg) = {
            let opts = self.options.read();
            let fkeys = opts.fkeys.clone();

            let mut screen_guard = self.screen.lock();
            let state = screen_guard
                .as_any_mut()
                .downcast_mut::<EditState>()
                .expect("AnsiEditor screen should always be EditState");
            let buffer = state.get_buffer();
            let caret = state.get_caret();
            let font_page = caret.font_page();
            let font = buffer.font(font_page).or_else(|| buffer.font(0)).cloned();
            let palette = buffer.palette.clone();
            (fkeys, font, palette, caret.attribute.foreground(), caret.attribute.background())
        };

        // Precedence:
        // 1) Tag dialogs (only when Tag tool is active)
        // 2) Char selector
        // 3) Outline selector (only when Font tool is active)

        if let Some(tag_tool) = self.active_tag_tool() {
            if let Some(tag_dialog) = &tag_tool.state().dialog {
                let modal_content = tag_dialog.view().map(move |m| map_msg(AnsiEditorCoreMessage::TagDialog(m)));
                return icy_engine_gui::ui::modal(main_layout, modal_content, map_msg(AnsiEditorCoreMessage::TagDialog(TagDialogMessage::Cancel)));
            }
            if let Some(tag_list_dialog) = &tag_tool.state().list_dialog {
                let modal_content = tag_list_dialog.view().map(move |m| map_msg(AnsiEditorCoreMessage::TagListDialog(m)));
                return icy_engine_gui::ui::modal(
                    main_layout,
                    modal_content,
                    map_msg(AnsiEditorCoreMessage::TagListDialog(TagListDialogMessage::Close)),
                );
            }
        }

        if let Some(target) = self.char_selector_target {
            let current_code = match target {
                CharSelectorTarget::FKeySlot(slot) => fkeys.code_at(fkeys.current_set(), slot),
                CharSelectorTarget::BrushChar => self.brush_paint_char() as u16,
            };

            let selector_canvas = CharSelector::new(current_code)
                .view(current_font, palette.clone(), caret_fg, caret_bg)
                .map(move |m| map_msg(AnsiEditorCoreMessage::CharSelector(m)));

            let modal_content = icy_engine_gui::ui::modal_container(selector_canvas, CHAR_SELECTOR_WIDTH);
            return icy_engine_gui::ui::modal(
                main_layout,
                modal_content,
                map_msg(AnsiEditorCoreMessage::CharSelector(CharSelectorMessage::Cancel)),
            );
        }

        if let Some(font) = self.active_font_tool() {
            if font.is_outline_selector_open() {
                let current_style = *self.options.read().font_outline_style.read();
                let selector_canvas = OutlineSelector::new(current_style)
                    .view()
                    .map(move |m| map_msg(AnsiEditorCoreMessage::OutlineSelector(m)));
                let modal_content = icy_engine_gui::ui::modal_container(selector_canvas, outline_selector_width());
                return icy_engine_gui::ui::modal(
                    main_layout,
                    modal_content,
                    map_msg(AnsiEditorCoreMessage::OutlineSelector(OutlineSelectorMessage::Cancel)),
                );
            }
        }

        main_layout
    }

    /// Renders the center canvas area (canvas + overlays).
    ///
    /// This is intentionally kept in the core editor so the surrounding layout/chrome
    /// can stay in `AnsiEditorMainArea`.
    /// Also used by `CharFontEditor` for TDF glyph editing.
    pub(crate) fn view<'a>(&'a self) -> Element<'a, AnsiEditorCoreMessage> {
        // Canvas is created FIRST so Terminal's shader renders and populates the shared cache.
        let canvas = self.canvas.view().map(AnsiEditorCoreMessage::Canvas);

        // Get scroll position from viewport for overlay positioning.
        let (scroll_x, scroll_y) = {
            let vp = self.canvas.terminal.viewport.read();
            (vp.scroll_x, vp.scroll_y)
        };

        // Get font dimensions for overlays.
        let (font_width, font_height) = {
            let screen = self.screen.lock();
            let size = screen.font_dimensions();
            (size.width as f32, size.height as f32)
        };

        // Caret + buffer dimensions for line numbers.
        let (caret_row, caret_col, buffer_height, buffer_width) = {
            let mut screen_guard = self.screen.lock();
            let state = screen_guard
                .as_any_mut()
                .downcast_mut::<EditState>()
                .expect("AnsiEditor screen should always be EditState");
            let caret = state.get_caret();
            let buffer = state.get_buffer();
            (caret.y as usize, caret.x as usize, buffer.height(), buffer.width() as usize)
        };

        // Build the center area with optional line numbers overlay and tag context menu.
        let mut center_layers: Vec<Element<'_, AnsiEditorCoreMessage>> = vec![iced::widget::container(canvas).width(Length::Fill).height(Length::Fill).into()];

        if self.show_line_numbers {
            let line_numbers_overlay = widget::line_numbers::line_numbers_overlay(
                self.canvas.terminal.render_info.clone(),
                buffer_width,
                buffer_height as usize,
                font_width,
                font_height,
                caret_row,
                caret_col,
                scroll_x,
                scroll_y,
            );
            center_layers.push(line_numbers_overlay);
        }

        // Add remote cursors overlay if there are any
        if !self.remote_cursors.is_empty() {
            let remote_cursors_overlay = widget::remote_cursors::remote_cursors_overlay(
                self.canvas.terminal.render_info.clone(),
                self.remote_cursors.clone(),
                font_width,
                font_height,
                scroll_x,
                scroll_y,
                buffer_width,
                buffer_height as usize,
            );
            center_layers.push(remote_cursors_overlay);
        }

        // Add tag context menu overlay if active.
        if let Some(tag_tool) = self.current_tool.as_any().downcast_ref::<tools::TagTool>() {
            if tag_tool.state().has_context_menu() {
                let display_scale = self.canvas.terminal.render_info.read().display_scale;
                if let Some(context_menu) = tag_tool
                    .state()
                    .view_context_menu_overlay(font_width, font_height, scroll_x, scroll_y, display_scale)
                {
                    center_layers.push(context_menu.map(AnsiEditorCoreMessage::ToolMessage));
                }
            }
        }

        iced::widget::stack(center_layers).width(Length::Fill).height(Length::Fill).into()
    }

    // NOTE (Layer-local coordinates)
    // ============================
    // The terminal/canvas events provide positions in *document* coordinates.
    // All *painting* operations (Brush/Pencil/Erase/Shapes) are ALWAYS executed in
    // *layer-local* coordinates, i.e. relative to the current layer's offset.
    // Do NOT pass document/global positions into brush algorithms.
    // Selection/mask operations are handled by EditState and keep using document coords.

    /// Compute half-block coordinates from widget-local pixel position.
    /// Returns layer-local half-block coordinates (Y has 2x resolution).
    /// `pixel_position` is widget-local (relative to terminal bounds).
    fn compute_half_block_pos(&self, pixel_position: (f32, f32)) -> icy_engine::Position {
        let render_info = self.canvas.terminal.render_info.read();
        let viewport = self.canvas.terminal.viewport.read();

        // Convert widget-local to screen coordinates (RenderInfo methods expect screen coords)
        let screen_x = render_info.bounds_x + pixel_position.0;
        let screen_y = render_info.bounds_y + pixel_position.1;

        // Get visible half-block coordinates (without scroll offset)
        let (cell_x, half_block_y) = render_info.screen_to_half_block_cell_unclamped(screen_x, screen_y);

        // scroll_x is in content coordinates - convert to columns
        let font_width = render_info.font_width.max(1.0);
        let scroll_offset_cols = (viewport.scroll_x / font_width).floor() as i32;

        // scroll_y is in content coordinates - convert to half-block lines (2x)
        let font_height = render_info.font_height.max(1.0);
        let scroll_offset_half_lines = (viewport.scroll_y / font_height * 2.0).floor() as i32;

        // Get absolute half-block coordinates (with scroll offset)
        let abs_half_block = icy_engine::Position::new(cell_x + scroll_offset_cols, half_block_y + scroll_offset_half_lines);

        // Convert to layer-local coordinates
        // In half-block space, layer Y offset is also doubled
        let layer_offset = self.with_edit_state_readonly(|state| {
            if let Some(layer) = state.get_cur_layer() {
                let offset = layer.offset();
                icy_engine::Position::new(offset.x, offset.y * 2)
            } else {
                icy_engine::Position::default()
            }
        });

        abs_half_block - layer_offset
    }

    /// Helper to access EditState without mutable borrow (uses shared lock internally)
    pub(crate) fn with_edit_state_readonly<R, F: FnOnce(&icy_engine_edit::EditState) -> R>(&self, f: F) -> R {
        let mut screen = self.screen.lock();
        let edit_state = screen
            .as_any_mut()
            .downcast_mut::<icy_engine_edit::EditState>()
            .expect("screen should be EditState");
        f(edit_state)
    }

    /// Helper to access EditState mutably without requiring &mut self (uses shared lock internally)
    /// This is useful for view functions that need to modify state but can only have &self
    pub(crate) fn with_edit_state_mut_shared<R, F: FnOnce(&mut icy_engine_edit::EditState) -> R>(&self, f: F) -> R {
        let mut screen = self.screen.lock();
        let edit_state = screen
            .as_any_mut()
            .downcast_mut::<icy_engine_edit::EditState>()
            .expect("screen should be EditState");
        f(edit_state)
    }

    fn hit_test_visible_layer_at_doc_pos(buffer: &TextBuffer, pos: icy_engine::Position) -> Option<usize> {
        // Prefer top-most visible layer.
        for (idx, layer) in buffer.layers.iter().enumerate().rev() {
            if !layer.is_visible() {
                continue;
            }

            if layer.rectangle().is_inside(pos) {
                return Some(idx);
            }
        }

        None
    }

    fn select_visible_layer_at_doc_pos_for_click_tool(&mut self, pos: icy_engine::Position) -> bool {
        if !matches!(self.current_tool.id(), tools::ToolId::Tool(Tool::Click)) {
            return false;
        }
        if self.is_paste_mode() {
            return false;
        }

        let changed = self.with_edit_state(|state| {
            let current = state.get_current_layer().ok();
            let hit = {
                let buffer = state.get_buffer();
                Self::hit_test_visible_layer_at_doc_pos(buffer, pos)
            };

            match (current, hit) {
                (Some(cur), Some(hit)) if hit != cur => {
                    state.set_current_layer(hit);
                    true
                }
                _ => false,
            }
        });

        if changed {
            self.update_layer_bounds();
        }

        changed
    }

    pub(super) fn active_tag_tool(&self) -> Option<&tools::TagTool> {
        self.current_tool.as_any().downcast_ref::<tools::TagTool>()
    }

    pub(super) fn active_tag_tool_mut(&mut self) -> Option<&mut tools::TagTool> {
        self.current_tool.as_any_mut().downcast_mut::<tools::TagTool>()
    }

    pub(super) fn active_font_tool(&self) -> Option<&tools::FontTool> {
        self.current_tool.as_any().downcast_ref::<tools::FontTool>()
    }

    pub(super) fn view_paste_toolbar(&self, view_ctx: &tools::ToolViewContext) -> Element<'_, tools::ToolMessage> {
        use tools::ToolHandler;
        self.paste_handler.view_toolbar(view_ctx)
    }

    pub(crate) fn view_current_tool_toolbar(&self, view_ctx: &tools::ToolViewContext) -> Element<'_, tools::ToolMessage> {
        self.current_tool.view_toolbar(view_ctx)
    }

    pub(super) fn brush_paint_char(&self) -> char {
        if let Some(pencil) = self.current_tool.as_any().downcast_ref::<tools::PencilTool>() {
            return pencil.paint_char();
        }
        if let Some(fill) = self.current_tool.as_any().downcast_ref::<tools::FillTool>() {
            return fill.paint_char();
        }
        if let Some(shape) = self.current_tool.as_any().downcast_ref::<tools::ShapeTool>() {
            return shape.paint_char();
        }
        ' '
    }

    // =========================================================================
    // Tool Handler Dispatch (new trait-based system)
    // =========================================================================

    fn build_half_block_mapper(&self, state: &EditState) -> tools::HalfBlockMapper {
        let render_info = self.canvas.terminal.render_info.read();
        let viewport = self.canvas.terminal.viewport.read();

        let layer_offset = state
            .get_cur_layer()
            .map(|l| {
                let o = l.offset();
                icy_engine::Position::new(o.x, o.y * 2)
            })
            .unwrap_or_default();

        tools::HalfBlockMapper {
            bounds_x: render_info.bounds_x,
            bounds_y: render_info.bounds_y,
            viewport_x: render_info.viewport_x,
            viewport_y: render_info.viewport_y,
            display_scale: render_info.display_scale,
            scan_lines: render_info.scan_lines,
            font_width: render_info.font_width,
            font_height: render_info.font_height,
            scroll_x: viewport.scroll_x,
            scroll_y: viewport.scroll_y,
            layer_offset,
        }
    }

    fn dispatch_current_tool_event(&mut self, event: &iced::Event) -> tools::ToolResult {
        self.tool_set_cursor_icon = false;
        let mut screen_guard = self.screen.lock();
        let state = screen_guard.as_any_mut().downcast_mut::<EditState>().unwrap();

        let mut undo_guard = None;
        let half_block_mapper = Some(self.build_half_block_mapper(state));

        let mut ctx = tools::ToolContext {
            state,
            options: Some(&self.options),
            undo_guard: &mut undo_guard,
            half_block_mapper,
        };

        let result = self.current_tool.handle_event(&mut ctx, event);
        drop(screen_guard);
        self.process_tool_result(result)
    }

    fn dispatch_current_tool_terminal_message(&mut self, msg: &TerminalMessage) -> tools::ToolResult {
        self.tool_set_cursor_icon = false;
        let mut screen_guard = self.screen.lock();
        let state = screen_guard.as_any_mut().downcast_mut::<EditState>().unwrap();

        let mut undo_guard = None;
        let half_block_mapper = Some(self.build_half_block_mapper(state));

        let mut ctx = tools::ToolContext {
            state,
            options: Some(&self.options),
            undo_guard: &mut undo_guard,
            half_block_mapper,
        };

        let result = self.current_tool.handle_terminal_message(&mut ctx, msg);
        drop(screen_guard);
        self.process_tool_result(result)
    }

    fn dispatch_paste_terminal_message(&mut self, msg: &TerminalMessage) -> tools::ToolResult {
        use tools::ToolHandler;

        self.tool_set_cursor_icon = false;

        let mut screen_guard = self.screen.lock();
        let state = screen_guard.as_any_mut().downcast_mut::<EditState>().unwrap();

        let mut undo_guard = None;
        let half_block_mapper = Some(self.build_half_block_mapper(state));
        let mut ctx = tools::ToolContext {
            state,
            options: Some(&self.options),
            undo_guard: &mut undo_guard,
            half_block_mapper,
        };

        let result = self.paste_handler.handle_terminal_message(&mut ctx, msg);
        drop(screen_guard);
        self.process_tool_result_from(MouseCaptureTarget::Paste, result)
    }

    fn dispatch_paste_event(&mut self, event: &iced::Event) -> tools::ToolResult {
        use tools::ToolHandler;

        self.tool_set_cursor_icon = false;

        let mut screen_guard = self.screen.lock();
        let state = screen_guard.as_any_mut().downcast_mut::<EditState>().unwrap();

        let mut undo_guard = None;
        let half_block_mapper = Some(self.build_half_block_mapper(state));
        let mut ctx = tools::ToolContext {
            state,
            options: Some(&self.options),
            undo_guard: &mut undo_guard,
            half_block_mapper,
        };

        let result = self.paste_handler.handle_event(&mut ctx, event);
        drop(screen_guard);
        self.process_tool_result_from(MouseCaptureTarget::Paste, result)
    }

    fn dispatch_paste_action(&mut self, action: tools::PasteAction) -> tools::ToolResult {
        let mut screen_guard = self.screen.lock();
        let state = screen_guard.as_any_mut().downcast_mut::<EditState>().unwrap();

        let result = self.paste_handler.perform_action(state, action);
        drop(screen_guard);
        self.process_tool_result_from(MouseCaptureTarget::Paste, result)
    }

    /// Process a ToolResult and perform editor-side effects.
    ///
    /// `source` is used to attribute mouse capture correctly (e.g. paste mode has its own capture).
    pub(super) fn process_tool_result_from(&mut self, source: MouseCaptureTarget, result: tools::ToolResult) -> tools::ToolResult {
        use tools::ToolResult;

        match result {
            ToolResult::None => ToolResult::None,
            ToolResult::Redraw => ToolResult::Redraw,
            ToolResult::Commit(msg) => {
                self.is_modified = true;
                // Char changes are now collected directly in EditState during push_undo_action
                ToolResult::Commit(msg)
            }
            ToolResult::Status(msg) => ToolResult::Status(msg),
            ToolResult::UpdateLayerBounds => {
                self.update_layer_bounds();
                ToolResult::None
            }
            ToolResult::SwitchTool(tool) => {
                self.pending_tool_switch = Some(tool);
                ToolResult::Redraw
            }
            ToolResult::StartCapture => {
                self.mouse_capture_tool = Some(source);
                self.is_dragging = true;
                ToolResult::None
            }
            ToolResult::EndCapture => {
                self.mouse_capture_tool = None;
                self.is_dragging = false;
                ToolResult::None
            }
            ToolResult::SetCursorIcon(icon) => {
                self.tool_set_cursor_icon = true;
                *self.canvas.terminal.cursor_icon.write() = icon;
                ToolResult::None
            }
            ToolResult::Ui(action) => {
                match action {
                    tools::UiAction::OpenCharSelectorForFKey(slot) => {
                        self.char_selector_target = Some(CharSelectorTarget::FKeySlot(slot));
                        ToolResult::Redraw
                    }
                    tools::UiAction::OpenCharSelectorForBrush => {
                        self.char_selector_target = Some(CharSelectorTarget::BrushChar);
                        ToolResult::Redraw
                    }
                    // Handled in `AnsiEditorCoreMessage::ToolMessage` because opening those dialogs
                    // needs returning a `Task` (bubbling into TopToolbar / MainWindow).
                    tools::UiAction::OpenTdfFontSelector | tools::UiAction::OpenFontDirectory => ToolResult::None,
                }
            }
            ToolResult::Multi(results) => {
                let mut last_result = ToolResult::None;
                for r in results {
                    last_result = self.process_tool_result_from(source, r);
                }
                last_result
            }
            // Collaboration events are collected and can be retrieved later
            ToolResult::CollabPasteAsSelection => {
                log::debug!("[Collab] Pushing PasteAsSelection event to queue");
                self.pending_collab_events.push(CollabToolEvent::PasteAsSelection);
                ToolResult::None
            }
            ToolResult::CollabOperation(x, y) => {
                log::debug!(
                    "[Collab] Pushing Operation({}, {}) event to queue, queue size: {}",
                    x,
                    y,
                    self.pending_collab_events.len() + 1
                );
                self.pending_collab_events.push(CollabToolEvent::Operation(x, y));
                ToolResult::None
            }
        }
    }

    /// Take pending collaboration events (clears the queue)
    pub fn take_pending_collab_events(&mut self) -> Vec<CollabToolEvent> {
        std::mem::take(&mut self.pending_collab_events)
    }

    /// Backwards-compatible entrypoint when the source is the currently active editor tool.
    pub(super) fn process_tool_result(&mut self, result: tools::ToolResult) -> tools::ToolResult {
        self.process_tool_result_from(MouseCaptureTarget::Tool, result)
    }

    /// Construct the core editor from a buffer.
    ///
    /// Returns (editor, palette, format_mode) so the public wrapper can initialize
    /// palette-dependent UI widgets.
    pub(crate) fn from_buffer_inner(
        buffer: TextBuffer,
        options: Arc<RwLock<Settings>>,
        current_tool: Box<dyn tools::ToolHandler>,
    ) -> (Self, icy_engine::Palette, icy_engine_edit::FormatMode) {
        // Clone the palette before moving buffer into EditState
        let palette = buffer.palette.clone();
        let format_mode = icy_engine_edit::FormatMode::from_buffer(&buffer);

        // Create EditState and wrap as Box<dyn Screen> for Terminal compatibility
        let edit_state = EditState::from_buffer(buffer);
        let screen: Arc<Mutex<Box<dyn Screen>>> = Arc::new(Mutex::new(Box::new(edit_state)));

        // Initialize outline style from shared settings
        let outline_style = { *options.read().font_outline_style.read() };
        {
            let mut guard = screen.lock();
            if let Some(state) = guard.as_any_mut().downcast_mut::<EditState>() {
                state.set_outline_style(outline_style);
            }
        }

        let mut color_switcher = ColorSwitcher::new();
        color_switcher.sync_palette(&palette);

        // Create canvas with cloned Arc to screen + shared monitor settings
        let shared_monitor_settings = { options.read().monitor_settings.clone() };
        let mut canvas = CanvasView::new(screen.clone(), shared_monitor_settings);
        // Enable caret blinking by default (Click tool is the default)
        canvas.set_has_focus(true);

        let top_toolbar = TopToolbar::new();

        // Read display settings before moving options
        let (show_line_numbers, show_layer_borders) = {
            let opts = options.read();
            (*opts.show_line_numbers.read(), *opts.show_layer_borders.read())
        };

        // Current tool is provided by the wrapper (which owns the registry).

        let mut editor = Self {
            screen,
            current_tool,
            top_toolbar,
            color_switcher,
            canvas,
            options,
            is_modified: false,

            // Selection/drag state
            is_dragging: false,
            mouse_capture_tool: None,
            selection_drag: SelectionDrag::None,
            start_selection: None,
            // Marker/guide state - disabled by default
            guide: None,
            show_guide: false,
            raster: None,
            show_raster: false,
            // Read from settings
            show_line_numbers,
            show_layer_borders,

            char_selector_target: None,

            paint_button: MouseButton::Left,

            shape_clear: false,
            paste_handler: tools::PasteTool::new(),

            tool_set_cursor_icon: false,

            pending_tool_switch: None,

            remote_cursors: Vec::new(),
            pending_collab_events: Vec::new(),
        };

        // Initialize marker-dependent uniforms (especially `layer_bounds`) so the selection
        // rendering is correct immediately after opening a file, without requiring a manual
        // layer selection click.
        editor.update_markers();
        editor.update_layer_bounds();

        *editor.canvas.terminal.cursor_icon.write() = Some(editor.current_tool.cursor());

        (editor, palette, format_mode)
    }

    /// Update remote cursors from collaboration state
    pub fn set_remote_cursors(&mut self, cursors: Vec<widget::remote_cursors::RemoteCursor>) {
        self.remote_cursors = cursors;
    }

    pub(super) fn clear_tool_overlay(&mut self) {
        self.canvas.set_tool_overlay_mask(None, None);
    }

    fn task_none_with_markers_update(&mut self) -> Task<AnsiEditorCoreMessage> {
        self.update_markers();
        Task::none()
    }

    fn task_none_with_layer_bounds_update(&mut self) -> Task<AnsiEditorCoreMessage> {
        self.update_layer_bounds();
        Task::none()
    }

    fn end_drag_capture(&mut self) {
        self.is_dragging = false;
        self.mouse_capture_tool = None;
        self.selection_drag = SelectionDrag::None;
        self.start_selection = None;
    }

    fn cancel_shape_drag(&mut self) -> bool {
        if self.is_dragging && Self::is_shape_tool_id(self.current_tool.id()) {
            self.end_drag_capture();
            self.paint_button = MouseButton::Left;
            self.shape_clear = false;
            self.clear_tool_overlay();
            return true;
        }
        false
    }

    /// Update the shape preview overlay during drag operations
    fn update_shape_preview(&mut self) {
        let Some(shape) = self.current_tool.as_any().downcast_ref::<tools::ShapeTool>() else {
            return;
        };

        let Some(snapshot) = shape.drag_snapshot() else {
            self.clear_tool_overlay();
            return;
        };

        // Get font dimensions and foreground color from caret
        let (font_width, font_height, paint_color) = {
            let screen = self.screen.lock();
            let font = screen.font(0);
            let (fw, fh) = if let Some(f) = font {
                let size = f.size();
                (size.width as f32, size.height as f32)
            } else {
                (8.0, 16.0)
            };

            // Get the foreground color from the caret attribute
            let caret_fg = screen.caret().attribute.foreground();
            let palette = screen.palette();
            let rgb = palette.rgb(caret_fg);

            (fw, fh, rgb)
        };

        // Get the current tool variant and brush settings from the shape tool
        let tool = shape.tool();
        let is_half_block = shape.brush_primary() == crate::ui::editor::ansi::widget::toolbar::top::BrushPrimaryMode::HalfBlock;

        let (mask, rect) = if is_half_block {
            // Half-block mode uses different coordinates
            let (Some(start_hb), Some(end_hb)) = (snapshot.start_half_block, snapshot.current_half_block) else {
                self.clear_tool_overlay();
                return;
            };
            tools::ShapeTool::overlay_mask_for_drag_half_block(tool, font_width, font_height, start_hb, end_hb, paint_color)
        } else {
            tools::ShapeTool::overlay_mask_for_drag(tool, font_width, font_height, snapshot.start_pos, snapshot.current_pos, paint_color)
        };
        self.canvas.set_tool_overlay_mask(mask, rect);
    }

    fn set_current_fkey_set(&mut self, set_idx: usize) {
        if let Some(click) = self.current_tool.as_any_mut().downcast_mut::<tools::ClickTool>() {
            click.set_current_fkey_set(&self.options, set_idx);
        }
    }

    fn type_fkey_slot(&mut self, slot: usize) -> tools::ToolResult {
        let Some(click) = self.current_tool.as_any_mut().downcast_mut::<tools::ClickTool>() else {
            return tools::ToolResult::None;
        };

        let set_idx = click.current_fkey_set();

        let mut screen_guard = self.screen.lock();
        if let Some(state) = screen_guard.as_any_mut().downcast_mut::<EditState>() {
            let mut undo_guard = None;
            let mut ctx = tools::ToolContext {
                state,
                options: Some(&self.options),
                undo_guard: &mut undo_guard,
                half_block_mapper: None,
            };
            let result = click.type_fkey_slot(&mut ctx, set_idx, slot);
            drop(screen_guard);
            return self.process_tool_result_from(MouseCaptureTarget::Tool, result);
        }

        tools::ToolResult::None
    }

    /// Access the EditState via downcast from the Screen trait object
    /// Panics if the screen is not an EditState (should never happen in AnsiEditor)
    pub(crate) fn with_edit_state<T, F: FnOnce(&mut EditState) -> T>(&mut self, f: F) -> T {
        let mut screen = self.screen.lock();
        let edit_state = screen
            .as_any_mut()
            .downcast_mut::<EditState>()
            .expect("AnsiEditor screen should always be EditState");
        f(edit_state)
    }

    /// Get undo stack length for dirty tracking
    pub fn undo_stack_len(&self) -> usize {
        let mut screen = self.screen.lock();
        if let Some(edit_state) = screen.as_any_mut().downcast_mut::<EditState>() {
            edit_state.undo_stack_len()
        } else {
            0
        }
    }

    /// Get a clone of the undo stack for serialization
    pub fn get_undo_stack(&self) -> Option<icy_engine_edit::EditorUndoStack> {
        let mut screen = self.screen.lock();
        if let Some(edit_state) = screen.as_any_mut().downcast_mut::<EditState>() {
            let stack = edit_state.get_undo_stack();
            let locked = stack.lock().unwrap();
            Some((*locked).clone())
        } else {
            None
        }
    }

    /// Restore undo stack from serialization
    pub fn set_undo_stack(&mut self, stack: icy_engine_edit::EditorUndoStack) {
        let mut screen = self.screen.lock();
        if let Some(edit_state) = screen.as_any_mut().downcast_mut::<EditState>() {
            let undo_stack = edit_state.get_undo_stack();
            let mut locked = undo_stack.lock().unwrap();
            *locked = stack;
        }
    }

    /// Get session data for serialization
    pub fn get_session_data(&self) -> Option<icy_engine_edit::AnsiEditorSessionState> {
        let mut screen = self.screen.lock();
        let edit_state = screen.as_any_mut().downcast_mut::<EditState>()?;

        let undo_stack = {
            let stack = edit_state.get_undo_stack();
            let locked = stack.lock().unwrap();
            (*locked).clone()
        };

        let buffer = edit_state.get_buffer();
        let caret = edit_state.get_caret().clone();

        // Get layer visibility
        let layer_visibility: Vec<bool> = buffer.layers.iter().map(|l| l.is_visible()).collect();

        Some(icy_engine_edit::AnsiEditorSessionState {
            version: 1,
            undo_stack,
            caret_position: caret.position(),
            caret_attribute: caret.attribute,
            scroll_offset: (0.0, 0.0),    // TODO: Get from canvas
            zoom_level: 1.0,              // TODO: Get from canvas
            auto_zoom: true,              // TODO: Get from canvas
            selected_tool: String::new(), // TODO: Get from tool panel
            outline_style: edit_state.get_outline_style(),
            mirror_mode: edit_state.get_mirror_mode(),
            current_tag: edit_state.get_current_tag().unwrap_or(0),
            layer_visibility,
            selected_layer: edit_state.get_current_layer().unwrap_or(0),
            sauce_meta: edit_state.get_sauce_meta().clone(),
            reference_image_path: None, // TODO: Get reference image path
            reference_image_opacity: 0.5,
        })
    }

    /// Restore session data from serialization
    pub fn set_session_data(&mut self, state: icy_engine_edit::AnsiEditorSessionState) {
        // Restore undo stack and all edit state properties
        let mut screen = self.screen.lock();
        if let Some(edit_state) = screen.as_any_mut().downcast_mut::<EditState>() {
            // Restore undo stack
            let undo_stack = edit_state.get_undo_stack();
            let mut locked = undo_stack.lock().unwrap();
            *locked = state.undo_stack;
            drop(locked);

            // Restore edit state properties
            edit_state.set_outline_style(state.outline_style);
            edit_state.set_mirror_mode(state.mirror_mode);
            edit_state.set_current_tag(state.current_tag);

            // Restore caret position and attribute
            edit_state.set_caret_position(state.caret_position);
            edit_state.set_caret_attribute(state.caret_attribute);

            // Restore selected layer
            edit_state.set_current_layer(state.selected_layer);

            // Restore layer visibility
            let buffer = edit_state.get_buffer_mut();
            for (i, visible) in state.layer_visibility.iter().enumerate() {
                if i < buffer.layers.len() {
                    buffer.layers[i].set_is_visible(*visible);
                }
            }
        }

        // TODO: Restore scroll and zoom from canvas
    }

    // ========================================================================
    // Clipboard operations
    // ========================================================================

    /// Check if cut operation is available (selection exists)
    #[allow(dead_code)]
    pub fn can_cut(&self) -> bool {
        self.with_edit_state_readonly(|state| state.selection().is_some())
    }

    /// Cut selection to clipboard
    pub fn cut(&mut self) -> Result<(), String> {
        self.copy_without_deselect()?;
        {
            let mut screen = self.screen.lock();
            if let Some(edit_state) = screen.as_any_mut().downcast_mut::<EditState>() {
                edit_state.erase_selection().map_err(|e| e.to_string())?;
                edit_state.clear_selection().map_err(|e| e.to_string())?;
            }
        }

        // Robustly reset transient selection/drag state and refresh shader markers.
        self.is_dragging = false;
        self.mouse_capture_tool = None;
        self.selection_drag = SelectionDrag::None;
        self.start_selection = None;
        self.refresh_selection_display();
        Ok(())
    }

    /// Check if copy operation is available (selection exists)
    #[allow(dead_code)]
    pub fn can_copy(&self) -> bool {
        self.with_edit_state_readonly(|state| state.selection().is_some())
    }

    /// Copy selection to clipboard in multiple formats (ICY, RTF, Text)
    pub fn copy(&mut self) -> Result<(), String> {
        self.copy_without_deselect()?;
        // Clear selection after copy
        {
            let mut screen = self.screen.lock();
            if let Some(edit_state) = screen.as_any_mut().downcast_mut::<EditState>() {
                edit_state.clear_selection().map_err(|e| e.to_string())?;
            }
        }

        // Robustly reset transient selection/drag state and refresh shader markers.
        self.is_dragging = false;
        self.mouse_capture_tool = None;
        self.selection_drag = SelectionDrag::None;
        self.start_selection = None;
        self.refresh_selection_display();
        Ok(())
    }

    /// Copy selection to clipboard without clearing the selection
    /// Used internally by cut() which handles its own selection clearing
    fn copy_without_deselect(&mut self) -> Result<(), String> {
        let mut screen = self.screen.lock();
        let edit_state = screen
            .as_any_mut()
            .downcast_mut::<EditState>()
            .ok_or_else(|| "Could not access edit state".to_string())?;

        let mut contents = Vec::new();

        // Debug: log selection state
        log::debug!("copy_without_deselect: selection={:?}", edit_state.selection());

        // Plain text (required - if no text, nothing to copy)
        let text = match edit_state.copy_text() {
            Some(t) => t,
            None => return Err("No selection to copy".to_string()),
        };

        // ICY binary format (for paste between ICY applications)
        if let Some(data) = edit_state.clipboard_data() {
            log::debug!("copy_without_deselect: ICY data size={}", data.len());
            contents.push(ClipboardContent::Other(ICY_CLIPBOARD_TYPE.into(), data));
        } else {
            log::warn!("copy_without_deselect: No ICY clipboard data generated");
        }

        // RTF (rich text with colors)
        if let Some(rich_text) = edit_state.copy_rich_text() {
            contents.push(ClipboardContent::Rtf(rich_text));
        }

        // Plain text - MUST be last on Windows
        contents.push(ClipboardContent::Text(text));

        // Set clipboard contents
        crate::CLIPBOARD_CONTEXT.set(contents).map_err(|e| format!("Failed to set clipboard: {e}"))?;

        Ok(())
    }

    /// Check if paste operation is available (clipboard has compatible content)
    #[allow(dead_code)]
    pub fn can_paste(&self) -> bool {
        self.paste_handler.can_paste()
    }

    /// Paste from clipboard (ICY format, image, or text)
    /// Creates a floating layer that can be positioned before anchoring
    pub fn paste(&mut self) -> Result<(), String> {
        // Don't paste if already in paste mode
        if self.is_paste_mode() {
            return Ok(());
        }

        let previous_tool = self.current_tool.id();

        let mut screen_guard = self.screen.lock();
        let state = screen_guard
            .as_any_mut()
            .downcast_mut::<EditState>()
            .ok_or_else(|| "Could not access edit state".to_string())?;

        let mut undo_guard = None;
        let half_block_mapper = Some(self.build_half_block_mapper(state));
        let mut ctx = tools::ToolContext {
            state,
            options: Some(&self.options),
            undo_guard: &mut undo_guard,
            half_block_mapper,
        };

        let result = self.paste_handler.paste_from_clipboard(&mut ctx, previous_tool)?;
        drop(screen_guard);
        let _ = self.process_tool_result(result);

        Ok(())
    }

    /// Check if we are in paste mode (floating layer active for positioning)
    /// This is the primary check for paste mode UI and input handling
    pub fn is_paste_mode(&self) -> bool {
        self.paste_handler.is_active()
    }

    /// Save the document to the given path
    pub fn save(&mut self, path: &std::path::Path) -> Result<(), String> {
        let mut screen = self.screen.lock();
        if let Some(edit_state) = screen.as_any_mut().downcast_ref::<EditState>() {
            // Always save ANSI editor as full-fidelity IcyDraw format.
            // Other formats are handled via Export.
            let format = FileFormat::IcyDraw;

            // Get buffer and save with default options
            let buffer = edit_state.get_buffer();
            let options = icy_engine::AnsiSaveOptionsV2::default();
            let bytes = format.to_bytes(buffer, &options).map_err(|e| e.to_string())?;

            std::fs::write(path, bytes).map_err(|e| e.to_string())?;

            self.is_modified = false;
            Ok(())
        } else {
            Err("Could not access edit state".to_string())
        }
    }

    /// Get the current marker state for menu display
    pub fn get_marker_menu_state(&self) -> widget::toolbar::menu_bar::MarkerMenuState {
        widget::toolbar::menu_bar::MarkerMenuState {
            guide: self.guide.map(|(x, y)| (x as u32, y as u32)),
            guide_visible: self.show_guide,
            raster: self.raster.map(|(x, y)| (x as u32, y as u32)),
            raster_visible: self.show_raster,
            line_numbers_visible: self.show_line_numbers,
            layer_borders_visible: self.show_layer_borders,
        }
    }

    /// Get the current mirror mode state
    pub fn get_mirror_mode(&self) -> bool {
        let mut screen = self.screen.lock();
        if let Some(state) = screen.as_any_mut().downcast_ref::<EditState>() {
            state.get_mirror_mode()
        } else {
            false
        }
    }

    /// Toggle mirror mode
    pub fn toggle_mirror_mode(&mut self) {
        let mut screen = self.screen.lock();
        if let Some(state) = screen.as_any_mut().downcast_mut::<EditState>() {
            let current = state.get_mirror_mode();
            state.set_mirror_mode(!current);
        }
    }

    /// Compute viewport info for the minimap overlay
    /// Returns normalized coordinates (0.0-1.0) representing the visible area in the terminal
    pub(super) fn compute_viewport_info(&self) -> ViewportInfo {
        // IMPORTANT: The terminal shader may clamp/fit the visible region (resolution/letterbox).
        // For a pixel-exact minimap overlay, use the effective values written by the shader.
        let cache = self.canvas.terminal.render_cache.read();
        widget::minimap::viewport_info_from_effective_view(
            cache.content_width as f32,
            cache.content_height,
            cache.visible_width,
            cache.visible_height,
            cache.scroll_offset_x,
            cache.scroll_offset_y,
        )
    }

    /// Scroll the canvas to show a character position (col, row)
    pub fn scroll_to_position(&mut self, col: i32, row: i32) {
        let (buf_width, buf_height) = {
            let mut screen_guard = self.screen.lock();
            let state = screen_guard
                .as_any_mut()
                .downcast_mut::<EditState>()
                .expect("AnsiEditor screen should always be EditState");
            let buffer = state.get_buffer();
            (buffer.width().max(1) as f32, buffer.height().max(1) as f32)
        };
        let norm_x: f32 = (col as f32 + 0.5) / buf_width;
        let norm_y: f32 = (row as f32 + 0.5) / buf_height;
        self.scroll_canvas_to_normalized(norm_x.clamp(0.0, 1.0), norm_y.clamp(0.0, 1.0));
    }

    /// Scroll the canvas to a normalized position (0.0-1.0)
    /// The viewport will be centered on this position
    pub(super) fn scroll_canvas_to_normalized(&mut self, norm_x: f32, norm_y: f32) {
        let cache = self.canvas.terminal.render_cache.read();
        let content_width = (cache.content_width as f32).max(1.0);
        let content_height = cache.content_height.max(1.0);
        let visible_width = cache.visible_width.max(1.0);
        let visible_height = cache.visible_height.max(1.0);
        drop(cache);

        // Keep current X when horizontal scrolling isn't possible.
        let current_scroll_x = self.canvas.terminal.viewport.read().scroll_x;

        let target_x = if content_width > visible_width {
            norm_x * content_width - visible_width / 2.0
        } else {
            current_scroll_x
        };

        // Convert normalized position to content coordinates
        // Center the viewport on the clicked position
        let target_y = norm_y * content_height - visible_height / 2.0;

        // Scroll to the target position (clamping is done internally)
        self.canvas.scroll_to(target_x, target_y);
    }

    /// Update the editor state with a core message
    pub fn update(&mut self, message: AnsiEditorCoreMessage) -> Task<AnsiEditorCoreMessage> {
        let task = match message {
            AnsiEditorCoreMessage::OpenTagListDialog => {
                // Route to the Tag tool (TagTool owns the list dialog state).
                self.update(AnsiEditorCoreMessage::ToolMessage(tools::ToolMessage::TagOpenList))
            }
            AnsiEditorCoreMessage::TagListDialog(msg) => {
                let screen = Arc::clone(&self.screen);
                let result = {
                    let mut screen_guard = screen.lock();
                    if let (Some(state), Some(tag_tool)) = (
                        screen_guard.as_any_mut().downcast_mut::<EditState>(),
                        self.current_tool.as_any_mut().downcast_mut::<tools::TagTool>(),
                    ) {
                        tag_tool.state_mut().handle_list_dialog_message(state, msg)
                    } else {
                        tools::ToolResult::None
                    }
                };

                let processed = self.process_tool_result(result);
                if !matches!(processed, tools::ToolResult::None) {
                    self.update_tag_overlays();
                    if let Some(tag_tool) = self.current_tool.as_any().downcast_ref::<tools::TagTool>() {
                        let should_clear = tag_tool.state().add_new_index.is_none() && !tag_tool.state().selection_drag_active;
                        if should_clear {
                            self.clear_tool_overlay();
                        }
                    }
                }

                Task::none()
            }
            AnsiEditorCoreMessage::TagDialog(msg) => {
                let screen = Arc::clone(&self.screen);
                let result = {
                    let mut screen_guard = screen.lock();
                    if let (Some(state), Some(tag_tool)) = (
                        screen_guard.as_any_mut().downcast_mut::<EditState>(),
                        self.current_tool.as_any_mut().downcast_mut::<tools::TagTool>(),
                    ) {
                        tag_tool.state_mut().handle_dialog_message(state, msg)
                    } else {
                        tools::ToolResult::None
                    }
                };

                let processed = self.process_tool_result(result);
                if !matches!(processed, tools::ToolResult::None) {
                    self.update_tag_overlays();
                    if let Some(tag_tool) = self.current_tool.as_any().downcast_ref::<tools::TagTool>() {
                        let should_clear = tag_tool.state().add_new_index.is_none() && !tag_tool.state().selection_drag_active;
                        if should_clear {
                            self.clear_tool_overlay();
                        }
                    }
                }

                Task::none()
            }
            AnsiEditorCoreMessage::Canvas(msg) => {
                // Forward terminal mouse events directly to tool handling
                self.handle_terminal_mouse_event(&msg);
                self.canvas.update(msg).map(AnsiEditorCoreMessage::Canvas)
            }
            AnsiEditorCoreMessage::TopToolbar(msg) => {
                // Intercept brush char-table requests here (keeps the dialog local to the editor)
                match msg {
                    TopToolbarMessage::OpenBrushCharTable => {
                        self.char_selector_target = Some(CharSelectorTarget::BrushChar);
                        Task::none()
                    }
                    TopToolbarMessage::SetBrushChar(_) => {
                        // Selecting a character implicitly closes the overlay.
                        self.char_selector_target = None;
                        let task = self.top_toolbar.update(msg).map(AnsiEditorCoreMessage::TopToolbar);
                        task
                    }
                    TopToolbarMessage::TypeFKey(slot) => {
                        let _ = self.type_fkey_slot(slot);
                        Task::none()
                    }
                    TopToolbarMessage::NextFKeyPage => {
                        if let Some(click) = self.current_tool.as_any().downcast_ref::<tools::ClickTool>() {
                            let next = click.current_fkey_set().saturating_add(1);
                            self.set_current_fkey_set(next);
                        }
                        Task::none()
                    }
                    TopToolbarMessage::PrevFKeyPage => {
                        if let Some(click) = self.current_tool.as_any().downcast_ref::<tools::ClickTool>() {
                            let cur = click.current_fkey_set();
                            let prev = {
                                let opts = self.options.read();
                                let count = opts.fkeys.set_count();
                                if count == 0 { 0 } else { (cur + count - 1) % count }
                            };
                            self.set_current_fkey_set(prev);
                        }
                        Task::none()
                    }
                    TopToolbarMessage::OpenFontDirectory => {
                        // Open the font directory in the system file manager
                        if let Some(font_dir) = Settings::font_dir() {
                            // Create directory if it doesn't exist
                            if !font_dir.exists() {
                                let _ = std::fs::create_dir_all(&font_dir);
                            }
                            if let Err(e) = open::that(&font_dir) {
                                log::warn!("Failed to open font directory: {}", e);
                            }
                        }
                        Task::none()
                    }
                    TopToolbarMessage::SelectFont(index) => {
                        if let Some(font) = self.current_tool.as_any_mut().downcast_mut::<tools::FontTool>() {
                            font.select_font(index);
                        }
                        Task::none()
                    }
                    TopToolbarMessage::SelectOutline(index) => {
                        // Update outline style in options
                        *self.options.read().font_outline_style.write() = index;
                        Task::none()
                    }
                    TopToolbarMessage::OpenOutlineSelector => {
                        // Open the outline selector popup
                        if let Some(font) = self.current_tool.as_any_mut().downcast_mut::<tools::FontTool>() {
                            font.open_outline_selector();
                        }
                        Task::none()
                    }
                    TopToolbarMessage::OpenFontSelector => {
                        // This will be handled by main_window to open the dialog
                        // Return a task that signals this (handled via Message routing)
                        Task::none()
                    }
                    TopToolbarMessage::OpenTagList => {
                        // Route to tag tool
                        self.update(AnsiEditorCoreMessage::ToolMessage(tools::ToolMessage::TagOpenList))
                    }
                    TopToolbarMessage::StartAddTag => {
                        // Toggle add-tag mode
                        self.update(AnsiEditorCoreMessage::ToolMessage(tools::ToolMessage::TagStartAdd))
                    }
                    TopToolbarMessage::EditSelectedTag => self.update(AnsiEditorCoreMessage::ToolMessage(tools::ToolMessage::TagEditSelected)),
                    TopToolbarMessage::DeleteSelectedTags => self.update(AnsiEditorCoreMessage::ToolMessage(tools::ToolMessage::TagDeleteSelected)),
                    TopToolbarMessage::ToggleFilled(v) => {
                        // Let the active tool decide whether it needs to switch variants.
                        let _ = self.update(AnsiEditorCoreMessage::ToolMessage(tools::ToolMessage::ToggleFilled(v)));

                        let task = self
                            .top_toolbar
                            .update(TopToolbarMessage::ToggleFilled(v))
                            .map(AnsiEditorCoreMessage::TopToolbar);
                        task
                    }

                    // === Paste Mode Actions ===
                    TopToolbarMessage::PasteStamp => {
                        let _ = self.dispatch_paste_action(tools::PasteAction::Stamp);
                        Task::none()
                    }
                    TopToolbarMessage::PasteRotate => {
                        let _ = self.dispatch_paste_action(tools::PasteAction::Rotate);
                        Task::none()
                    }
                    TopToolbarMessage::PasteFlipX => {
                        let _ = self.dispatch_paste_action(tools::PasteAction::FlipX);
                        Task::none()
                    }
                    TopToolbarMessage::PasteFlipY => {
                        let _ = self.dispatch_paste_action(tools::PasteAction::FlipY);
                        Task::none()
                    }
                    TopToolbarMessage::PasteToggleTransparent => {
                        let _ = self.dispatch_paste_action(tools::PasteAction::ToggleTransparent);
                        Task::none()
                    }
                    TopToolbarMessage::PasteAnchor => {
                        let _ = self.dispatch_paste_action(tools::PasteAction::Anchor);
                        Task::none()
                    }
                    TopToolbarMessage::PasteKeepAsLayer => {
                        let _ = self.dispatch_paste_action(tools::PasteAction::KeepAsLayer);
                        Task::none()
                    }
                    TopToolbarMessage::PasteCancel => {
                        let _ = self.dispatch_paste_action(tools::PasteAction::Discard);
                        Task::none()
                    }
                    TopToolbarMessage::PasteMove(dx, dy) => {
                        let _ = self.dispatch_paste_action(tools::PasteAction::Move(dx, dy));
                        Task::none()
                    }

                    _ => self.top_toolbar.update(msg).map(AnsiEditorCoreMessage::TopToolbar),
                }
            }
            AnsiEditorCoreMessage::ToolMessage(msg) => {
                use tools::ToolHandler;

                let paste_mode = self.is_paste_mode();
                let _current_tool_id = self.current_tool.id();

                let mut screen_guard = self.screen.lock();
                let Some(state) = screen_guard.as_any_mut().downcast_mut::<EditState>() else {
                    return Task::none();
                };

                let mut undo_guard = None;
                let mut ctx = tools::ToolContext {
                    state,
                    options: Some(&self.options),
                    undo_guard: &mut undo_guard,
                    half_block_mapper: None,
                };

                let (source, result) = if paste_mode {
                    (MouseCaptureTarget::Paste, self.paste_handler.handle_message(&mut ctx, &msg))
                } else {
                    (MouseCaptureTarget::Tool, self.current_tool.handle_message(&mut ctx, &msg))
                };

                drop(screen_guard);

                if !paste_mode {
                    // Font tool opens dialogs via UiAction, but needs a Task to bubble up.
                    let pending_task = match &result {
                        tools::ToolResult::Ui(tools::UiAction::OpenTdfFontSelector) => {
                            Some(Task::done(AnsiEditorCoreMessage::TopToolbar(TopToolbarMessage::OpenFontSelector)))
                        }
                        tools::ToolResult::Ui(tools::UiAction::OpenFontDirectory) => {
                            Some(Task::done(AnsiEditorCoreMessage::TopToolbar(TopToolbarMessage::OpenFontDirectory)))
                        }
                        _ => None,
                    };

                    if let Some(task) = pending_task {
                        let _ = self.process_tool_result_from(source, result);
                        return task;
                    }
                }

                let processed = self.process_tool_result_from(source, result);

                if self.current_tool.id() == tools::ToolId::Tool(Tool::Tag) && !matches!(processed, tools::ToolResult::None) {
                    self.update_tag_overlays();
                    if let Some(tag_tool) = self.current_tool.as_any().downcast_ref::<tools::TagTool>() {
                        if tag_tool.state().add_new_index.is_none() && !tag_tool.state().selection_drag_active {
                            self.clear_tool_overlay();
                        }
                    }
                }

                Task::none()
            }
            AnsiEditorCoreMessage::CharSelector(msg) => {
                match msg {
                    CharSelectorMessage::SelectChar(code) => {
                        match self.char_selector_target {
                            Some(CharSelectorTarget::FKeySlot(slot)) => {
                                // Update the F-key slot with the selected character
                                if let Some(click) = self.current_tool.as_any_mut().downcast_mut::<tools::ClickTool>() {
                                    let set_idx = click.current_fkey_set();
                                    let fkeys_to_save = {
                                        let mut opts = self.options.write();
                                        opts.fkeys.set_code_at(set_idx, slot, code);
                                        opts.fkeys.clone()
                                    };
                                    // Trigger async save
                                    std::thread::spawn(move || {
                                        let _ = fkeys_to_save.save();
                                    });
                                    click.clear_fkey_cache();
                                }
                            }
                            Some(CharSelectorTarget::BrushChar) => {
                                let ch = char::from_u32(code as u32).unwrap_or(' ');
                                // Route brush char selection back to the active tool.
                                let msg = tools::ToolMessage::SetBrushChar(ch);
                                let _ = self.update(AnsiEditorCoreMessage::ToolMessage(msg));
                            }
                            None => {}
                        }
                        self.char_selector_target = None;
                    }
                    CharSelectorMessage::Cancel => {
                        self.char_selector_target = None;
                    }
                }
                Task::none()
            }
            AnsiEditorCoreMessage::OutlineSelector(msg) => {
                if let Some(font) = self.current_tool.as_any_mut().downcast_mut::<tools::FontTool>() {
                    font.handle_outline_selector_message(&self.options, msg);
                }
                Task::none()
            }

            // 
            // CORE MESSAGES - Layer Operations
            // 
            AnsiEditorCoreMessage::SelectLayer(idx) => {
                self.with_edit_state(|state| {
                    // Keep caret at the same absolute document position when switching layers.
                    // Caret coordinates are layer-local, so we translate via the layer offsets.
                    let old_offset = state.get_cur_layer().map(|l| l.offset()).unwrap_or_default();
                    let abs_caret = state.get_caret().position() + old_offset;

                    state.set_current_layer(idx);

                    let new_offset = state.get_cur_layer().map(|l| l.offset()).unwrap_or_default();
                    state.set_caret_position(abs_caret - new_offset);
                });
                self.task_none_with_layer_bounds_update()
            }
            AnsiEditorCoreMessage::ToggleLayerVisibility(idx) => {
                let result = self.with_edit_state(move |state| state.toggle_layer_visibility(idx));
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::AddLayer => {
                let current_layer = self.with_edit_state(|state| state.get_current_layer().unwrap_or(0));
                let result = self.with_edit_state(|state| state.add_new_layer(current_layer));
                if result.is_ok() {
                    self.is_modified = true;
                    self.update_layer_bounds();
                }
                Task::none()
            }
            AnsiEditorCoreMessage::RemoveLayer(idx) => {
                // Don't allow removing the last layer
                let layer_count = self.with_edit_state(|state| state.get_buffer().layers.len());
                if layer_count > 1 {
                    let result = self.with_edit_state(|state| state.remove_layer(idx));
                    if result.is_ok() {
                        self.is_modified = true;
                        self.update_layer_bounds();
                    }
                }
                Task::none()
            }
            AnsiEditorCoreMessage::MoveLayerUp(idx) => {
                let result = self.with_edit_state(|state| state.raise_layer(idx));
                if result.is_ok() {
                    self.is_modified = true;
                    self.update_layer_bounds();
                }
                Task::none()
            }
            AnsiEditorCoreMessage::MoveLayerDown(idx) => {
                let result = self.with_edit_state(|state| state.lower_layer(idx));
                if result.is_ok() {
                    self.is_modified = true;
                    self.update_layer_bounds();
                }
                Task::none()
            }
            AnsiEditorCoreMessage::DuplicateLayer(idx) => {
                let result = self.with_edit_state(|state| state.duplicate_layer(idx));
                if result.is_ok() {
                    self.is_modified = true;
                    self.update_layer_bounds();
                }
                Task::none()
            }
            AnsiEditorCoreMessage::MergeLayerDown(idx) => {
                let result = self.with_edit_state(|state| state.merge_layer_down(idx));
                if result.is_ok() {
                    self.is_modified = true;
                    self.update_layer_bounds();
                }
                Task::none()
            }
            AnsiEditorCoreMessage::ClearLayer(idx) => {
                let result = self.with_edit_state(|state| state.clear_layer(idx));
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::ScrollViewport(dx, dy) => {
                self.canvas.scroll_by(dx, dy);
                Task::none()
            }

            // === Marker/Guide Messages ===
            AnsiEditorCoreMessage::SetGuide(x, y) => {
                if x <= 0 && y <= 0 {
                    self.guide = None;
                } else {
                    self.guide = Some((x as f32, y as f32));
                    self.show_guide = true;
                }
                self.task_none_with_markers_update()
            }
            AnsiEditorCoreMessage::ClearGuide => {
                self.guide = None;
                self.task_none_with_markers_update()
            }
            AnsiEditorCoreMessage::SetRaster(x, y) => {
                if x <= 0 && y <= 0 {
                    self.raster = None;
                } else {
                    self.raster = Some((x as f32, y as f32));
                    self.show_raster = true;
                }
                self.task_none_with_markers_update()
            }
            AnsiEditorCoreMessage::ClearRaster => {
                self.raster = None;
                self.task_none_with_markers_update()
            }
            AnsiEditorCoreMessage::ToggleGuide => {
                self.show_guide = !self.show_guide;
                self.task_none_with_markers_update()
            }
            AnsiEditorCoreMessage::ToggleRaster => {
                self.show_raster = !self.show_raster;
                self.task_none_with_markers_update()
            }
            AnsiEditorCoreMessage::ToggleLineNumbers => {
                self.show_line_numbers = !self.show_line_numbers;
                // Persist to settings
                *self.options.read().show_line_numbers.write() = self.show_line_numbers;
                self.options.read().store_persistent();
                Task::none()
            }
            AnsiEditorCoreMessage::ToggleLayerBorders => {
                self.show_layer_borders = !self.show_layer_borders;
                // Persist to settings
                *self.options.read().show_layer_borders.write() = self.show_layer_borders;
                self.options.read().store_persistent();
                self.task_none_with_layer_bounds_update()
            }
            AnsiEditorCoreMessage::ToggleMirrorMode => {
                self.toggle_mirror_mode();
                Task::none()
            }

            // 
            // Area operations
            // 
            AnsiEditorCoreMessage::JustifyLineCenter => {
                let result = self.with_edit_state(|state| state.center_line());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::JustifyLineLeft => {
                let result = self.with_edit_state(|state| state.justify_line_left());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::JustifyLineRight => {
                let result = self.with_edit_state(|state| state.justify_line_right());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::InsertRow => {
                let result = self.with_edit_state(|state| state.insert_row());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::DeleteRow => {
                let result = self.with_edit_state(|state| state.delete_row());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::InsertColumn => {
                let result = self.with_edit_state(|state| state.insert_column());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::DeleteColumn => {
                let result = self.with_edit_state(|state| state.delete_column());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::EraseRow => {
                let result = self.with_edit_state(|state| state.erase_row());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::EraseRowToStart => {
                let result = self.with_edit_state(|state| state.erase_row_to_start());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::EraseRowToEnd => {
                let result = self.with_edit_state(|state| state.erase_row_to_end());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::EraseColumn => {
                let result = self.with_edit_state(|state| state.erase_column());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::EraseColumnToStart => {
                let result = self.with_edit_state(|state| state.erase_column_to_start());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::EraseColumnToEnd => {
                let result = self.with_edit_state(|state| state.erase_column_to_end());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::ScrollAreaUp => {
                let result = self.with_edit_state(|state| state.scroll_area_up());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::ScrollAreaDown => {
                let result = self.with_edit_state(|state| state.scroll_area_down());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::ScrollAreaLeft => {
                let result = self.with_edit_state(|state| state.scroll_area_left());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }
            AnsiEditorCoreMessage::ScrollAreaRight => {
                let result = self.with_edit_state(|state| state.scroll_area_right());
                if result.is_ok() {
                    self.is_modified = true;
                }
                Task::none()
            }

            // 
            // Reference Image - Core actions
            // 
            AnsiEditorCoreMessage::ApplyReferenceImage(path, alpha) => {
                self.set_reference_image(Some(path), alpha);
                Task::none()
            }
            AnsiEditorCoreMessage::ClearReferenceImage => {
                self.set_reference_image(None, 0.0);
                Task::none()
            }
            AnsiEditorCoreMessage::ToggleReferenceImage => {
                self.toggle_reference_image();
                Task::none()
            }
            // 
            // Transform operations
            // 
            AnsiEditorCoreMessage::FlipX => {
                self.with_edit_state(|state| {
                    let _ = state.flip_x();
                });
                Task::none()
            }
            AnsiEditorCoreMessage::FlipY => {
                self.with_edit_state(|state| {
                    let _ = state.flip_y();
                });
                Task::none()
            }
            AnsiEditorCoreMessage::Crop => {
                self.with_edit_state(|state| {
                    let _ = state.crop();
                });
                Task::none()
            }
            AnsiEditorCoreMessage::JustifyCenter => {
                self.with_edit_state(|state| {
                    let _ = state.center();
                });
                Task::none()
            }
            AnsiEditorCoreMessage::JustifyLeft => {
                self.with_edit_state(|state| {
                    let _ = state.justify_left();
                });
                Task::none()
            }
            AnsiEditorCoreMessage::JustifyRight => {
                self.with_edit_state(|state| {
                    let _ = state.justify_right();
                });
                Task::none()
            }
            // 
            // Color operations
            // 
            AnsiEditorCoreMessage::NextFgColor => {
                self.with_edit_state(|state| {
                    let fg = state.get_caret().attribute.foreground();
                    let pal_len = state.get_buffer().palette.len();
                    let new_fg = (fg as usize + 1) % pal_len;
                    state.set_caret_foreground(new_fg as u32);
                });
                self.sync_ui();
                Task::none()
            }
            AnsiEditorCoreMessage::PrevFgColor => {
                self.with_edit_state(|state| {
                    let fg = state.get_caret().attribute.foreground();
                    let pal_len = state.get_buffer().palette.len();
                    let new_fg = if fg == 0 { pal_len - 1 } else { fg as usize - 1 };
                    state.set_caret_foreground(new_fg as u32);
                });
                self.sync_ui();
                Task::none()
            }
            AnsiEditorCoreMessage::NextBgColor => {
                self.with_edit_state(|state| {
                    let bg = state.get_caret().attribute.background();
                    let pal_len = state.get_buffer().palette.len();
                    let new_bg = (bg as usize + 1) % pal_len;
                    state.set_caret_background(new_bg as u32);
                });
                self.sync_ui();
                Task::none()
            }
            AnsiEditorCoreMessage::PrevBgColor => {
                self.with_edit_state(|state| {
                    let bg = state.get_caret().attribute.background();
                    let pal_len = state.get_buffer().palette.len();
                    let new_bg = if bg == 0 { pal_len - 1 } else { bg as usize - 1 };
                    state.set_caret_background(new_bg as u32);
                });
                self.sync_ui();
                Task::none()
            }
            AnsiEditorCoreMessage::PickAttributeUnderCaret => {
                self.with_edit_state(|state| {
                    let pos = state.get_caret().position();
                    let attr = if let Some(layer) = state.get_cur_layer() {
                        layer.char_at(pos + layer.offset()).attribute
                    } else {
                        state.get_buffer().char_at(pos).attribute
                    };
                    state.set_caret_foreground(attr.foreground());
                    state.set_caret_background(attr.background());
                });
                self.sync_ui();
                Task::none()
            }
            AnsiEditorCoreMessage::ToggleColor => {
                self.with_edit_state(|state| {
                    state.swap_caret_colors();
                });
                self.sync_ui();
                Task::none()
            }
            AnsiEditorCoreMessage::SwitchToDefaultColor => {
                self.with_edit_state(|state| state.reset_caret_colors());
                self.sync_ui();
                Task::none()
            }

            // 
            // CORE MESSAGES - Font Apply Operations
            // 
            AnsiEditorCoreMessage::ApplyFontSelection(result) => {
                self.with_edit_state(|state| {
                    use super::FontSelectorResult;
                    match result {
                        FontSelectorResult::SingleFont(font) => {
                            let slot = state.get_caret().font_page();
                            let _ = state.set_font_in_slot(slot, font);
                        }
                        FontSelectorResult::FontForSlot { slot, font } => {
                            state.set_caret_font_page(slot);
                            let _ = state.set_font_in_slot(slot, font);
                        }
                    }
                });
                Task::none()
            }
            AnsiEditorCoreMessage::ApplyFontSlotChange(result) => {
                self.with_edit_state(|state| {
                    use super::FontSlotManagerResult;
                    match result {
                        FontSlotManagerResult::SelectSlot { slot } => {
                            state.set_caret_font_page(slot);
                        }
                        FontSlotManagerResult::ResetSlot { slot, font } => {
                            if let Some(f) = font {
                                let _ = state.set_font_in_slot(slot, f);
                            }
                        }
                        FontSlotManagerResult::RemoveSlot { slot } => {
                            state.get_buffer_mut().remove_font(slot);
                        }
                        FontSlotManagerResult::OpenFontSelector { .. } => {
                            // Handled by MainWindow intercept
                        }
                        FontSlotManagerResult::AddSlot { slot, font } => {
                            let _ = state.set_font_in_slot(slot, font);
                        }
                    }
                });
                Task::none()
            }

            // 
            // CORE MESSAGES - Selection Operations
            // 
            AnsiEditorCoreMessage::Deselect => {
                let _ = self.with_edit_state(|state| state.clear_selection());
                self.refresh_selection_display();
                Task::none()
            }
            AnsiEditorCoreMessage::DeleteSelection => {
                let result = self.with_edit_state(|state| {
                    if state.is_something_selected() {
                        state.erase_selection()
                    } else {
                        state.delete_key()
                    }
                });
                if result.is_ok() {
                    self.is_modified = true;
                }
                self.refresh_selection_display();
                Task::none()
            }
        };

        task
    }

    /// Check if there's a pending tool switch request
    pub fn take_pending_tool_switch(&mut self) -> Option<tools::ToolId> {
        self.pending_tool_switch.take()
    }

    /// Update the canvas markers based on current guide/raster settings
    fn update_markers(&mut self) {
        // Get font dimensions from screen for pixel conversion
        let (font_width, font_height) = {
            let screen = self.screen.lock();
            let font = screen.font(0);
            if let Some(f) = font {
                let size = f.size();
                (size.width as f32, size.height as f32)
            } else {
                (8.0, 16.0) // Default fallback
            }
        };

        // Update raster grid in pixel coordinates
        if self.show_raster {
            if let Some((cols, rows)) = self.raster {
                // Convert character spacing to pixel spacing
                let pixel_width = cols * font_width;
                let pixel_height = rows * font_height;
                self.canvas.set_raster(Some((pixel_width, pixel_height)));
            } else {
                self.canvas.set_raster(None);
            }
        } else {
            self.canvas.set_raster(None);
        }

        // Update guide crosshair in pixel coordinates
        if self.show_guide {
            if let Some((col, row)) = self.guide {
                // Convert character position to pixel position
                let pixel_x = col * font_width;
                let pixel_y = row * font_height;
                self.canvas.set_guide(Some((pixel_x, pixel_y)));
            } else {
                self.canvas.set_guide(None);
            }
        } else {
            self.canvas.set_guide(None);
        }
    }

    /// Update the layer bounds display based on current layer selection
    fn update_layer_bounds(&mut self) {
        // In paste mode, always show layer borders so the floating layer is visible
        let is_paste = self.is_paste_mode();
        let show_borders = self.show_layer_borders || is_paste;
        self.canvas.set_show_layer_borders(show_borders);
        self.canvas.set_paste_mode(is_paste);
        // Get current layer info from EditState
        let (layer_bounds, caret_origin_px) = {
            let mut screen = self.screen.lock();

            // Get font dimensions for pixel conversion
            let font = screen.font(0);
            let (font_width, font_height) = if let Some(f) = font {
                let size = f.size();
                (size.width as f32, size.height as f32)
            } else {
                (8.0, 16.0) // Default fallback
            };

            // Access the EditState to get buffer and current layer
            if let Some(edit_state) = screen.as_any_mut().downcast_mut::<EditState>() {
                let buffer = edit_state.get_buffer();

                // Caret should be rendered relative to the *current* layer.
                let caret_origin_px = edit_state
                    .get_current_layer()
                    .ok()
                    .and_then(|idx| buffer.layers.get(idx))
                    .map(|layer| {
                        let offset = layer.offset();
                        (offset.x as f32 * font_width, offset.y as f32 * font_height)
                    })
                    .unwrap_or((0.0, 0.0));

                // In paste mode, find the floating layer instead of current layer
                let target_layer = if edit_state.has_floating_layer() {
                    buffer.layers.iter().enumerate().find(|(_, l)| l.role.is_paste()).map(|(i, _)| i)
                } else {
                    edit_state.get_current_layer().ok()
                };

                if let Some(layer_idx) = target_layer {
                    if let Some(layer) = buffer.layers.get(layer_idx) {
                        // Use offset() which respects preview_offset during drag
                        let offset = layer.offset();
                        let size = layer.size();
                        let width = size.width;
                        let height = size.height;

                        // Convert to pixels
                        let x = offset.x as f32 * font_width;
                        let y = offset.y as f32 * font_height;
                        let w = width as f32 * font_width;
                        let h = height as f32 * font_height;

                        (Some((x, y, w, h)), caret_origin_px)
                    } else {
                        (None, caret_origin_px)
                    }
                } else {
                    (None, caret_origin_px)
                }
            } else {
                (None, (0.0, 0.0))
            }
        };

        self.canvas.set_layer_bounds(layer_bounds, true);
        self.canvas.set_caret_origin_px(caret_origin_px);
    }

    /// Update tag rectangle overlays when Tag tool is active
    pub(super) fn update_tag_overlays(&mut self) {
        // Snapshot selection from TagTool state (only when Tag tool is active).
        let selection: Vec<usize> = self
            .current_tool
            .as_any()
            .downcast_ref::<tools::TagTool>()
            .map(|t| t.state().selection.clone())
            .unwrap_or_default();

        // First, get all the data we need (position, length, is_selected)
        let (font_width, font_height, tag_data): (f32, f32, Vec<(icy_engine::Position, usize, bool)>) = {
            let mut screen = self.screen.lock();

            // Get font dimensions for pixel conversion
            let font = screen.font(0);
            let (fw, fh) = if let Some(f) = font {
                let size = f.size();
                (size.width as f32, size.height as f32)
            } else {
                (8.0, 16.0) // Default fallback
            };

            // Access EditState to get tags and update overlay mask
            let tags = if let Some(edit_state) = screen.as_any_mut().downcast_mut::<EditState>() {
                let tag_info = edit_state
                    .get_buffer()
                    .tags
                    .iter()
                    .enumerate()
                    .map(|(idx, tag)| (tag.position, tag.len(), selection.contains(&idx)))
                    .collect();
                tools::TagTool::update_overlay_mask_in_state(edit_state);
                tag_info
            } else {
                vec![]
            };

            (fw, fh, tags)
        };

        // Now render overlay to canvas (no longer holding screen lock)
        let (mask, rect) = tools::TagTool::overlay_mask_for_tags(font_width, font_height, &tag_data);
        self.canvas.set_tool_overlay_mask(mask, rect);
    }

    /// Update the selection display in the shader
    fn update_selection_display(&mut self) {
        use icy_engine::AddType;
        use icy_engine_gui::selection_colors;

        // Get selection from EditState and convert to pixel coordinates
        let (selection_rect, selection_color, selection_mask_data, font_dimensions) = {
            let mut screen = self.screen.lock();

            // Get font dimensions for pixel conversion
            let size = screen.font_dimensions();
            let font_width = size.width as f32;
            let font_height = size.height as f32;

            // Access the EditState to get selection
            if let Some(edit_state) = screen.as_any_mut().downcast_mut::<EditState>() {
                // Get the selection mask
                let selection_mask = edit_state.selection_mask();
                let selection = edit_state.selection();

                // Determine selection color based on add_type
                let selection_color = match selection.map(|s| s.add_type) {
                    Some(AddType::Add) => selection_colors::ADD,
                    Some(AddType::Subtract) => selection_colors::SUBTRACT,
                    _ => selection_colors::DEFAULT,
                };

                // Check if selection mask has content
                if !selection_mask.is_empty() {
                    // Generate texture data from selection mask.
                    // IMPORTANT: the shader samples this mask in *document cell coordinates* (0..buffer_w/0..buffer_h),
                    // so the texture must cover the full document size (no cropping/bounding-rect).
                    let buffer = edit_state.get_buffer();
                    let width = buffer.width().max(1) as u32;
                    let height = buffer.height().max(1) as u32;

                    // Create RGBA texture data (4 bytes per pixel)
                    let mut rgba_data = vec![0u8; (width * height * 4) as usize];

                    for y in 0..height {
                        for x in 0..width {
                            let doc_x = x as i32;
                            let doc_y = y as i32;
                            let is_selected = selection_mask.is_selected(icy_engine::Position::new(doc_x, doc_y));

                            let pixel_idx = ((y * width + x) * 4) as usize;
                            if is_selected {
                                // White = selected
                                rgba_data[pixel_idx] = 255;
                                rgba_data[pixel_idx + 1] = 255;
                                rgba_data[pixel_idx + 2] = 255;
                                rgba_data[pixel_idx + 3] = 255;
                            } else {
                                // Black = not selected
                                rgba_data[pixel_idx] = 0;
                                rgba_data[pixel_idx + 1] = 0;
                                rgba_data[pixel_idx + 2] = 0;
                                rgba_data[pixel_idx + 3] = 255;
                            }
                        }
                    }

                    // Selection rect is the *active* rectangular selection only (if present), not the mask bounds.
                    let selection_rect = selection.map(|sel| {
                        let rect = sel.as_rectangle();
                        let x = rect.left() as f32 * font_width;
                        let y = rect.top() as f32 * font_height;
                        let w = (rect.width() + 1) as f32 * font_width;
                        let h = (rect.height() + 1) as f32 * font_height;
                        (x, y, w, h)
                    });

                    (
                        selection_rect,
                        selection_color,
                        Some((rgba_data, width, height)),
                        Some((font_width, font_height)),
                    )
                } else if let Some(sel) = selection {
                    // No mask, but have selection rectangle
                    let rect = sel.as_rectangle();
                    let x = rect.left() as f32 * font_width;
                    let y = rect.top() as f32 * font_height;
                    let w = (rect.width() + 1) as f32 * font_width;
                    let h = (rect.height() + 1) as f32 * font_height;

                    (Some((x, y, w, h)), selection_color, None, Some((font_width, font_height)))
                } else {
                    (None, selection_colors::DEFAULT, None, None)
                }
            } else {
                (None, selection_colors::DEFAULT, None, None)
            }
        };

        self.canvas.set_selection(selection_rect);
        self.canvas.set_selection_color(selection_color);
        self.canvas.set_selection_mask(selection_mask_data, font_dimensions);
    }

    /// Set or update the reference image
    pub fn set_reference_image(&mut self, path: Option<PathBuf>, alpha: f32) {
        self.canvas.set_reference_image(path, alpha);
    }

    /// Toggle reference image visibility
    pub fn toggle_reference_image(&mut self) {
        self.canvas.toggle_reference_image();
    }

    /// Handle top-level window/input events that must reach the editor even when
    /// the inner widgets don't receive them (focus loss, cursor leaving window,
    /// global key presses).
    ///
    /// Returns `true` if the event was handled.
    pub fn handle_event(&mut self, event: &iced::Event) -> bool {
        match event {
            // Cancel transient shape drag/overlay on focus loss or when the cursor leaves the window.
            iced::Event::Window(iced::window::Event::Unfocused) | iced::Event::Mouse(iced::mouse::Event::CursorLeft) => {
                let _ = self.cancel_shape_drag();
                // Also reset mouse capture state in case drag ended outside the widget
                if self.mouse_capture_tool.is_some() {
                    self.current_tool.cancel_capture();
                    self.paste_handler.cancel_capture();
                }
                self.is_dragging = false;
                self.mouse_capture_tool = None;
                true
            }
            // Reset mouse capture state - the release may have happened outside the terminal widget
            iced::Event::Mouse(iced::mouse::Event::ButtonReleased(iced::mouse::Button::Left)) => {
                if self.mouse_capture_tool.is_some() {
                    self.current_tool.cancel_capture();
                    self.paste_handler.cancel_capture();
                }
                self.is_dragging = false;
                self.mouse_capture_tool = None;
                true
            }
            // Forward keyboard events directly into the editor.
            iced::Event::Keyboard(iced::keyboard::Event::KeyPressed { key, modifiers: _, .. }) => {
                // Character selector overlay has priority and is closed with Escape.
                if self.char_selector_target.is_some() {
                    if matches!(key, iced::keyboard::Key::Named(iced::keyboard::key::Named::Escape)) {
                        self.char_selector_target = None;
                        return true;
                    }
                }

                // Editor-owned Escape handling for transient shape drag overlays.
                if matches!(key, iced::keyboard::Key::Named(iced::keyboard::key::Named::Escape)) {
                    let _ = self.cancel_shape_drag();
                }

                // Paste mode has priority for special keys (handled by PasteTool)
                if self.is_paste_mode() {
                    log::debug!("handle_key_press: key={:?}, paste_mode=true", key);
                    let result = self.dispatch_paste_event(event);
                    if !matches!(result, tools::ToolResult::None) {
                        return true;
                    }
                }

                // Tool-specific key events are owned by the active tool.
                let result = self.dispatch_current_tool_event(event);

                // UI-only updates owned by the editor.
                match self.current_tool.id() {
                    tools::ToolId::Tool(Tool::Click | Tool::Font | Tool::Select) => {
                        if !matches!(result, tools::ToolResult::None) {
                            self.update_selection_display();
                        }
                    }
                    tools::ToolId::Tool(Tool::Tag) => {
                        if !matches!(result, tools::ToolResult::None) {
                            self.update_tag_overlays();
                            if let Some(tag_tool) = self.current_tool.as_any().downcast_ref::<tools::TagTool>() {
                                if tag_tool.state().add_new_index.is_none() && !tag_tool.state().selection_drag_active {
                                    self.clear_tool_overlay();
                                }
                            }
                        }
                    }
                    _ => {}
                }

                true
            }
            _ => false,
        }
    }

    /// Handle terminal mouse events directly from icy_engine_gui
    fn handle_terminal_mouse_event(&mut self, msg: &TerminalMessage) {
        match msg {
            TerminalMessage::Press(evt) => {
                if evt.text_position.is_none() {
                    return;
                }

                // In Click tool: determine which *visible* layer is under the cursor (document coords)
                // and switch current layer before dispatch so tools operate on the correct layer.
                if let Some(pos) = evt.text_position {
                    self.select_visible_layer_at_doc_pos_for_click_tool(pos);
                }

                // Paste mode always has priority.
                if self.is_paste_mode() {
                    let _ = self.dispatch_paste_terminal_message(msg);
                    return;
                }

                let _result = self.dispatch_current_tool_terminal_message(msg);

                // Post-dispatch UI updates
                match self.current_tool.id() {
                    tools::ToolId::Tool(Tool::Click | Tool::Font | Tool::Select) => {
                        self.update_selection_display();
                    }
                    tools::ToolId::Tool(Tool::Tag) => {
                        self.update_tag_overlays();
                    }
                    _ => {}
                }
            }
            TerminalMessage::Release(evt) => {
                if evt.text_position.is_none() {
                    return;
                }

                let target = self.mouse_capture_tool.unwrap_or_else(|| {
                    if self.is_paste_mode() {
                        MouseCaptureTarget::Paste
                    } else {
                        MouseCaptureTarget::Tool
                    }
                });

                let _result = match target {
                    MouseCaptureTarget::Paste => self.dispatch_paste_terminal_message(msg),
                    MouseCaptureTarget::Tool => {
                        let ev = self.dispatch_current_tool_terminal_message(msg);

                        match self.current_tool.id() {
                            tools::ToolId::Tool(Tool::Click | Tool::Font | Tool::Select) => {
                                self.update_selection_display();
                            }
                            tools::ToolId::Tool(Tool::Tag) => {
                                self.update_tag_overlays();
                                if let Some(tag_tool) = self.current_tool.as_any().downcast_ref::<tools::TagTool>() {
                                    if !tag_tool.state().selection_drag_active {
                                        self.clear_tool_overlay();
                                    }
                                }
                            }
                            id if Self::is_shape_tool_id(id) => {
                                // Clear shape preview overlay after release
                                self.clear_tool_overlay();
                            }
                            _ => {}
                        }

                        ev
                    }
                };
            }
            TerminalMessage::Move(evt) | TerminalMessage::Drag(evt) => {
                use tools::ToolHandler;

                let Some(pos) = evt.text_position else {
                    return;
                };

                // Brush hover preview is editor-owned UI.
                self.update_brush_preview(pos, evt.pixel_position);

                let target = self.mouse_capture_tool.unwrap_or_else(|| {
                    if self.is_paste_mode() {
                        MouseCaptureTarget::Paste
                    } else {
                        MouseCaptureTarget::Tool
                    }
                });

                let _result = match target {
                    MouseCaptureTarget::Paste => self.dispatch_paste_terminal_message(msg),
                    MouseCaptureTarget::Tool => {
                        let ev = self.dispatch_current_tool_terminal_message(msg);

                        match self.current_tool.id() {
                            tools::ToolId::Tool(Tool::Select) => {
                                self.update_selection_display();
                                if let Some(select) = self.current_tool.as_any().downcast_ref::<tools::SelectTool>() {
                                    *self.canvas.terminal.cursor_icon.write() = Some(select.cursor());
                                }
                            }
                            tools::ToolId::Tool(Tool::Click | Tool::Font) => {
                                self.update_selection_display();
                                if let Some(click) = self.current_tool.as_any().downcast_ref::<tools::ClickTool>() {
                                    *self.canvas.terminal.cursor_icon.write() = Some(click.cursor());
                                }
                            }
                            tools::ToolId::Tool(Tool::Tag) => {
                                self.update_tag_overlays();
                                if let Some(tag_tool) = self.current_tool.as_any().downcast_ref::<tools::TagTool>() {
                                    if tag_tool.state().selection_drag_active {
                                        let (font_width, font_height) = {
                                            let screen = self.screen.lock();
                                            let font = screen.font(0);
                                            if let Some(f) = font {
                                                let size = f.size();
                                                (size.width as f32, size.height as f32)
                                            } else {
                                                (8.0, 16.0)
                                            }
                                        };

                                        let (mask, rect) = tools::TagTool::overlay_mask_for_selection_drag(
                                            font_width,
                                            font_height,
                                            tag_tool.state().drag_start,
                                            tag_tool.state().drag_cur,
                                        );
                                        self.canvas.set_tool_overlay_mask(mask, rect);
                                    }
                                }
                            }
                            id if Self::is_shape_tool_id(id) => {
                                // Update shape preview overlay during drag
                                self.update_shape_preview();
                            }
                            _ => {}
                        }

                        // Baseline cursor for all tools: follow the active tool's preference.
                        // If the tool explicitly set a cursor icon via ToolResult, keep that.
                        if !self.tool_set_cursor_icon {
                            *self.canvas.terminal.cursor_icon.write() = Some(self.current_tool.cursor());
                        }

                        // Hover hint (Click tool only): if the cursor is over a *different* visible layer,
                        // show a pointer cursor to indicate layer switching is possible.
                        if !self.is_dragging
                            && self.mouse_capture_tool.is_none()
                            && matches!(self.current_tool.id(), tools::ToolId::Tool(Tool::Click))
                            && !self.is_paste_mode()
                        {
                            let (hit, current) = self.with_edit_state_readonly(|state| {
                                let current = state.get_current_layer().ok();
                                let hit = Self::hit_test_visible_layer_at_doc_pos(state.get_buffer(), pos);
                                (hit, current)
                            });

                            if let (Some(hit), Some(cur)) = (hit, current) {
                                if hit != cur {
                                    *self.canvas.terminal.cursor_icon.write() = Some(iced::mouse::Interaction::Pointer);
                                }
                            }
                        }

                        ev
                    }
                };
            }
            TerminalMessage::Scroll(delta) => match delta {
                iced::mouse::ScrollDelta::Lines { x, y } => {
                    self.canvas.scroll_by(*x * 20.0, *y * 20.0);
                }
                iced::mouse::ScrollDelta::Pixels { x, y } => {
                    self.canvas.scroll_by(*x, *y);
                }
            },
            TerminalMessage::Zoom(_) => {
                // Zoom is handled elsewhere
            }
        }
    }

    fn update_brush_preview(&mut self, pos: icy_engine::Position, pixel_position: (f32, f32)) {
        if self.current_tool.id() != tools::ToolId::Tool(Tool::Pencil) {
            self.canvas.set_brush_preview(None);
            return;
        }

        let Some(pencil) = self.current_tool.as_any().downcast_ref::<tools::PencilTool>() else {
            self.canvas.set_brush_preview(None);
            return;
        };

        let brush_size = pencil.brush_size().max(1) as i32;
        let half = brush_size / 2;

        // Get font dimensions for pixel conversion
        let (font_w, font_h) = {
            let screen = self.screen.lock();
            let size = screen.font_dimensions();
            (size.width as f32, size.height as f32)
        };

        let is_half_block_mode = matches!(pencil.brush_primary(), BrushPrimaryMode::HalfBlock);

        let rect = if is_half_block_mode {
            // Compute doc-space half-block coordinate (Y doubled)
            let layer_offset = self.with_edit_state_readonly(|state| state.get_cur_layer().map(|l| l.offset()).unwrap_or_default());

            let hb_layer = self.compute_half_block_pos(pixel_position);
            let hb_doc = icy_engine::Position::new(hb_layer.x + layer_offset.x, hb_layer.y + layer_offset.y * 2);

            let left_hb = hb_doc.x - half;
            let top_hb = hb_doc.y - half;

            let x = left_hb as f32 * font_w;
            let y = top_hb as f32 * (font_h * 0.5);
            let w = brush_size as f32 * font_w;
            let h = brush_size as f32 * (font_h * 0.5);
            Some((x, y, w, h))
        } else {
            // Normal (cell) mode in doc coordinates
            let left = pos.x - half;
            let top = pos.y - half;

            let x = left as f32 * font_w;
            let y = top as f32 * font_h;
            let w = brush_size as f32 * font_w;
            let h = brush_size as f32 * font_h;
            Some((x, y, w, h))
        };

        self.canvas.set_brush_preview(rect);
    }

    // view() moved to `AnsiEditorMainArea` (see `main_area.rs`).

    /// Sync UI components with the current edit state
    /// Call this after operations that may change the palette or tags
    pub fn sync_ui(&mut self) {
        let (palette, format_mode) = self.with_edit_state(|state| (state.get_buffer().palette.clone(), state.get_format_mode()));
        let _palette_limit = (format_mode == icy_engine_edit::FormatMode::XBinExtended).then_some(8);
        self.color_switcher.sync_palette(&palette);
        // Tag selection pruning is handled by the wrapper (owns the tool registry).
        if self.current_tool.id() == tools::ToolId::Tool(Tool::Tag) {
            self.update_tag_overlays();
        }
    }

    /// Update viewport size after document size changes.
    /// Call this after operations that change the buffer dimensions (e.g., apply_remote_document).
    pub fn update_viewport_size(&mut self) {
        self.canvas.update_viewport_size();
        self.update_layer_bounds();
    }

    /// Refresh selection + selection-mask overlay data sent to the shader.
    /// Useful for menu/command actions executed outside the editor's own input handling.
    pub fn refresh_selection_display(&mut self) {
        self.update_selection_display();
    }

    /// Get status bar information for this editor
    pub fn status_info(&self) -> AnsiStatusInfo {
        let mut screen = self.screen.lock();
        let state = screen
            .as_any_mut()
            .downcast_mut::<EditState>()
            .expect("AnsiEditor screen should always be EditState");
        let buffer = state.get_buffer();
        let caret = state.get_caret();
        let current_layer = state.get_current_layer().unwrap_or(0);
        let format_mode = state.get_format_mode();

        // Get font info based on format mode
        let (font_name, current_font_slot, slot_fonts) = if format_mode == icy_engine_edit::FormatMode::XBinExtended {
            let slot0 = buffer.font(0).map(|f| f.name().to_string());
            let slot1 = buffer.font(1).map(|f| f.name().to_string());
            let current_slot = caret.font_page().min(1);
            (
                slot0.clone().or(slot1.clone()).unwrap_or_else(|| "Unknown".to_string()),
                current_slot,
                Some([slot0, slot1]),
            )
        } else {
            // Get font for current slot, falling back to slot 0 if not found
            let font_page = caret.font_page();
            let font_name = buffer
                .font(font_page)
                .or_else(|| buffer.font(0))
                .map(|f| f.name().to_string())
                .unwrap_or_else(|| "Unknown".to_string());
            (font_name, font_page, None)
        };

        // Get paste layer info if in paste mode
        let (paste_layer_position, paste_layer_size) = if state.has_floating_layer() {
            buffer
                .layers
                .iter()
                .find(|l| l.role.is_paste())
                .map(|layer| {
                    let offset = layer.offset();
                    let size = layer.size();
                    (Some((offset.x, offset.y)), Some((size.width, size.height)))
                })
                .unwrap_or((None, None))
        } else {
            (None, None)
        };

        AnsiStatusInfo {
            cursor_position: (caret.x, caret.y),
            buffer_size: (buffer.width(), buffer.height()),
            current_layer,
            total_layers: buffer.layers.len(),
            current_tool: self.current_tool_for_panel().name().to_string(),
            insert_mode: caret.insert_mode,
            font_name,
            format_mode,
            current_font_slot,
            slot_fonts,
            paste_layer_position,
            paste_layer_size,
        }
    }

    pub(crate) fn current_tool_for_panel(&self) -> Tool {
        match self.current_tool.id() {
            tools::ToolId::Tool(t) => t,
            tools::ToolId::Paste => Tool::Click,
        }
    }

    /// Check if the current tool shows cursor position for collaboration
    ///
    /// Tools like Click and Select show cursor to other users.
    /// Drawing tools hide cursor since the user is focused on drawing.
    pub fn current_tool_shows_cursor(&self) -> bool {
        match self.current_tool.id() {
            tools::ToolId::Tool(t) => t.shows_cursor_for_collaboration(),
            tools::ToolId::Paste => false, // Paste mode hides cursor
        }
    }

    fn is_shape_tool_id(id: tools::ToolId) -> bool {
        matches!(
            id,
            tools::ToolId::Tool(Tool::Line | Tool::RectangleOutline | Tool::RectangleFilled | Tool::EllipseOutline | Tool::EllipseFilled)
        )
    }

    pub(crate) fn change_tool(&mut self, tool_registry: &mut tool_registry::ToolRegistry, tool: tools::ToolId) {
        self.change_tool_internal(tool_registry, tool, false)
    }

    /// Force change tool even if the tool ID is the same (used when switching registries)
    pub(crate) fn force_change_tool(&mut self, tool_registry: &mut tool_registry::ToolRegistry, tool: tools::ToolId) {
        self.change_tool_internal(tool_registry, tool, true)
    }

    fn change_tool_internal(&mut self, tool_registry: &mut tool_registry::ToolRegistry, tool: tools::ToolId, force: bool) {
        // Block tool changes during paste mode - must anchor or cancel first
        if self.is_paste_mode() {
            return;
        }

        // If capture is still set but we're not dragging anymore (e.g. drag got cancelled
        // via keyboard without any subsequent mouse move), clear it so tool switching
        // cannot get stuck.
        if !self.is_dragging && self.mouse_capture_tool.is_some() {
            self.mouse_capture_tool = None;
        }

        // Block tool changes while a drag is in progress.
        if self.is_dragging {
            return;
        }

        if !force && self.current_tool.id() == tool {
            return;
        }

        // Check if the current tool and the new tool share the same handler (e.g., all shape tools).
        // If so, just reconfigure the current tool instead of swapping with the registry.
        if let tools::ToolId::Tool(new_tool_variant) = tool {
            if self.current_tool.is_same_handler(new_tool_variant) {
                // Reconfigure the current tool (e.g., switch Line -> Rectangle in ShapeTool)
                if let Some(shape) = self.current_tool.as_any_mut().downcast_mut::<tools::ShapeTool>() {
                    shape.set_tool(new_tool_variant);
                }
                return;
            }
        }

        // Cancels any in-progress shape preview/drag when switching tools.
        let _ = self.cancel_shape_drag();

        let mut is_visble = matches!(tool, tools::ToolId::Tool(Tool::Click | Tool::Font));
        is_visble &= self.with_edit_state(|state: &mut EditState| {
            state.set_caret_visible(is_visble && state.selection().is_none());
            state.selection().is_none()
        });

        // Enable terminal focus for caret blinking in Click/Font tools
        self.canvas.set_has_focus(is_visble);

        // Swap current tool with one from the registry.
        let new_tool = tool_registry.take_for(tool);
        let old_tool = std::mem::replace(&mut self.current_tool, new_tool);
        tool_registry.put_back(old_tool);

        self.tool_set_cursor_icon = false;
        *self.canvas.terminal.cursor_icon.write() = Some(self.current_tool.cursor());

        // Clear tool hover preview when switching tools.
        if !matches!(tool, tools::ToolId::Tool(Tool::Pencil)) {
            self.canvas.set_brush_preview(None);
        }

        // Update tag overlays when switching to/from Tag tool
        if tool == tools::ToolId::Tool(Tool::Tag) {
            self.update_tag_overlays();
        } else {
            // Clear tag overlays when leaving Tag tool
            self.canvas.set_tool_overlay_mask(None, None);
        }
        // Fonts are loaded centrally via FontLibrary - no per-editor loading needed
    }
}
